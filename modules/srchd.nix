# srchd service module - Multi-project support
# Hosts multiple srchd instances at *.srchd.domain
# Each project has its own db.sqlite, shares code via symlinks

{ config, lib, pkgs, domain, srchdAuth, ... }:

let
  nodejs = pkgs.nodejs_22;

  # Directories
  srchdBase = "/var/lib/srchd";           # Base installation (code + node_modules)
  projectsDir = "/var/lib/srchd-projects"; # Per-project directories
  acmeChallengeDir = "/var/lib/acme/acme-challenge";
  basePort = 13370;                        # Base port for projects

  # Auth args
  authArgs = if srchdAuth != "" then "-a ${srchdAuth}" else "";

  # Discovery script - manages projects, services, and nginx config
  discoveryScript = pkgs.writeShellScriptBin "srchd-discover" ''
    set -e

    SRCHD_BASE="${srchdBase}"
    PROJECTS_DIR="${projectsDir}"
    BASE_PORT=${toString basePort}
    NGINX_CONF="/etc/nginx/srchd-projects.conf"
    INDEX_FILE="${srchdBase}/index.html"
    ACME_CHALLENGE="${acmeChallengeDir}"

    # Files to symlink from base installation
    SYMLINK_FILES="node_modules src package.json package-lock.json tsconfig.json drizzle.config.ts"

    echo "=== srchd Discovery ==="

    # Ensure directories exist
    mkdir -p "$PROJECTS_DIR" "$ACME_CHALLENGE"

    # Find all projects (directories containing db.sqlite)
    PROJECTS=""
    declare -A PROJECT_PORTS
    port_counter=0

    for dir in "$PROJECTS_DIR"/*/; do
      [ -d "$dir" ] || continue
      project=$(basename "$dir")
      if [ -f "$dir/db.sqlite" ]; then
        echo "Found project: $project"
        PROJECTS="$PROJECTS $project"

        # Get or assign port
        if [ -f "$dir/.port" ]; then
          port=$(cat "$dir/.port")
        else
          port=$((BASE_PORT + port_counter))
          echo "$port" > "$dir/.port"
        fi
        PROJECT_PORTS[$project]=$port
        port_counter=$((port_counter + 1))
        echo "  Port: $port"

        # Set up symlinks if not present
        for file in $SYMLINK_FILES; do
          if [ -e "$SRCHD_BASE/$file" ] && [ ! -e "$dir/$file" ]; then
            ln -sf "$SRCHD_BASE/$file" "$dir/$file"
            echo "  Linked $file"
          fi
        done

        # Start service if not running
        if ! systemctl is-active --quiet "srchd@$project"; then
          echo "  Starting srchd@$project"
          systemctl start "srchd@$project" || true
        fi
      fi
    done

    # Stop services for removed projects
    for service in $(systemctl list-units --type=service --state=running --no-legend | grep '^srchd@' | awk '{print $1}'); do
      project=$(echo "$service" | sed 's/srchd@\(.*\)\.service/\1/')
      if [ ! -f "$PROJECTS_DIR/$project/db.sqlite" ]; then
        echo "Stopping removed project: $project"
        systemctl stop "$service" || true
      fi
    done

    # Generate nginx config
    echo "Generating nginx config..."
    cat > "$NGINX_CONF" << 'NGINX_HEADER'
# Auto-generated by srchd-discover - DO NOT EDIT
NGINX_HEADER

    for project in $PROJECTS; do
      port=''${PROJECT_PORTS[$project]}
      subdomain="$project.srchd.${domain}"
      cert_dir="/var/lib/acme/$subdomain"
      has_cert="false"

      if [ -f "$cert_dir/fullchain.pem" ] && [ -f "$cert_dir/key.pem" ]; then
        has_cert="true"
      fi

      cat >> "$NGINX_CONF" << NGINX_PROJECT

# Project: $project
upstream srchd_$project {
    server 127.0.0.1:$port;
}

server {
    listen 80;
    listen [::]:80;
    server_name $subdomain;

    # ACME challenge location
    location /.well-known/acme-challenge/ {
        root $ACME_CHALLENGE;
    }

NGINX_PROJECT

      if [ "$has_cert" = "true" ]; then
        cat >> "$NGINX_CONF" << NGINX_REDIRECT
    # Redirect to HTTPS
    location / {
        return 301 https://\$server_name\$request_uri;
    }
}

server {
    listen 443 ssl;
    listen [::]:443 ssl;
    server_name $subdomain;

    ssl_certificate $cert_dir/fullchain.pem;
    ssl_certificate_key $cert_dir/key.pem;

    location / {
        proxy_pass http://srchd_$project;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }
}
NGINX_REDIRECT
      else
        # No cert yet - serve via HTTP and proxy (for cert acquisition)
        cat >> "$NGINX_CONF" << NGINX_HTTP_ONLY
    # No cert yet - serving via HTTP
    location / {
        proxy_pass http://srchd_$project;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }
}
NGINX_HTTP_ONLY
      fi
    done

    # Reload nginx first (needed for ACME challenges)
    echo "Reloading nginx..."
    systemctl reload nginx || echo "WARNING: nginx reload failed"

    # Request certificates for projects that don't have them
    for project in $PROJECTS; do
      subdomain="$project.srchd.${domain}"
      cert_dir="/var/lib/acme/$subdomain"

      if [ ! -f "$cert_dir/fullchain.pem" ]; then
        echo "Requesting certificate for $subdomain..."
        mkdir -p "$cert_dir"

        # Use certbot with webroot
        ${pkgs.certbot}/bin/certbot certonly \
          --webroot -w "$ACME_CHALLENGE" \
          -d "$subdomain" \
          --non-interactive --agree-tos \
          --email "security@${domain}" \
          --deploy-hook "systemctl reload nginx" \
          2>&1 || echo "  (Certificate request failed - check DNS for $subdomain)"

        # Certbot stores certs in /etc/letsencrypt, copy them (symlinks don't work due to permissions)
        if [ -d "/etc/letsencrypt/live/$subdomain" ]; then
          cp "/etc/letsencrypt/live/$subdomain/fullchain.pem" "$cert_dir/fullchain.pem"
          cp "/etc/letsencrypt/live/$subdomain/privkey.pem" "$cert_dir/key.pem"
          chmod 644 "$cert_dir/fullchain.pem"
          chmod 640 "$cert_dir/key.pem"
          chown root:nginx "$cert_dir/key.pem"
          echo "  Certificate obtained!"
        fi
      fi
    done

    # Regenerate nginx config now that we might have new certs
    # (Re-run the config generation)
    cat > "$NGINX_CONF" << 'NGINX_HEADER2'
# Auto-generated by srchd-discover - DO NOT EDIT
NGINX_HEADER2

    for project in $PROJECTS; do
      port=''${PROJECT_PORTS[$project]}
      subdomain="$project.srchd.${domain}"
      cert_dir="/var/lib/acme/$subdomain"
      has_cert="false"

      if [ -f "$cert_dir/fullchain.pem" ] && [ -f "$cert_dir/key.pem" ]; then
        has_cert="true"
      fi

      cat >> "$NGINX_CONF" << NGINX_PROJECT2

# Project: $project
upstream srchd_$project {
    server 127.0.0.1:$port;
}

server {
    listen 80;
    listen [::]:80;
    server_name $subdomain;

    location /.well-known/acme-challenge/ {
        root $ACME_CHALLENGE;
    }

NGINX_PROJECT2

      if [ "$has_cert" = "true" ]; then
        cat >> "$NGINX_CONF" << NGINX_REDIRECT2
    location / {
        return 301 https://\$server_name\$request_uri;
    }
}

server {
    listen 443 ssl;
    listen [::]:443 ssl;
    server_name $subdomain;

    ssl_certificate $cert_dir/fullchain.pem;
    ssl_certificate_key $cert_dir/key.pem;

    location / {
        proxy_pass http://srchd_$project;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }
}
NGINX_REDIRECT2
      else
        cat >> "$NGINX_CONF" << NGINX_HTTP_ONLY2
    location / {
        proxy_pass http://srchd_$project;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }
}
NGINX_HTTP_ONLY2
      fi
    done

    # Final nginx reload
    echo "Final nginx reload..."
    systemctl reload nginx || echo "WARNING: nginx reload failed"

    # Generate index page
    echo "Generating index page..."
    cat > "$INDEX_FILE" << 'INDEX_HEADER'
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>srchd Projects</title>
  <style>
    body { font-family: monospace; margin: 40px; background: #fff; line-height: 1.6; }
    h1 { border-bottom: 2px solid #333; padding-bottom: 10px; }
    .project { margin: 15px 0; padding: 15px; border: 1px solid #ddd; border-radius: 4px; }
    .project a { color: #0066cc; text-decoration: none; font-size: 1.2em; font-weight: bold; }
    .project a:hover { text-decoration: underline; }
    .no-ssl { color: #cc6600; font-size: 0.8em; }
  </style>
</head>
<body>
  <h1>srchd Experiment Viewer</h1>
  <p>Available projects:</p>
INDEX_HEADER

    for project in $PROJECTS; do
      subdomain="$project.srchd.${domain}"
      cert_dir="/var/lib/acme/$subdomain"

      # Get display title from .title file, or use project name
      if [ -f "$PROJECTS_DIR/$project/.title" ]; then
        title=$(cat "$PROJECTS_DIR/$project/.title")
      else
        title="$project"
      fi

      if [ -f "$cert_dir/fullchain.pem" ]; then
        cat >> "$INDEX_FILE" << INDEX_PROJECT_SSL
  <div class="project">
    <a href="https://$subdomain/">$title</a>
  </div>
INDEX_PROJECT_SSL
      else
        cat >> "$INDEX_FILE" << INDEX_PROJECT_NOSSL
  <div class="project">
    <a href="http://$subdomain/">$title</a>
    <span class="no-ssl">(pending SSL)</span>
  </div>
INDEX_PROJECT_NOSSL
      fi
    done

    if [ -z "$PROJECTS" ]; then
      echo "  <p><em>No projects found. Add a db.sqlite to ${projectsDir}/&lt;project-name&gt;/</em></p>" >> "$INDEX_FILE"
    fi

    cat >> "$INDEX_FILE" << 'INDEX_FOOTER'
</body>
</html>
INDEX_FOOTER

    echo "=== Discovery complete ==="
  '';

  # Script to read port from project directory
  getPortScript = pkgs.writeShellScriptBin "srchd-get-port" ''
    PROJECT="$1"
    PORT_FILE="${projectsDir}/$PROJECT/.port"
    if [ -f "$PORT_FILE" ]; then
      cat "$PORT_FILE"
    else
      echo "${toString basePort}"
    fi
  '';

in
{
  # Install required packages
  environment.systemPackages = with pkgs; [
    nodejs
    git
    certbot
    discoveryScript
    getPortScript
  ];

  # Create directories
  systemd.tmpfiles.rules = [
    "d ${srchdBase} 0755 root root -"
    "d ${projectsDir} 0755 root root -"
    "d ${acmeChallengeDir} 0755 root root -"
  ];

  # Base installation service (one-time setup)
  systemd.services.srchd-base = {
    description = "srchd base installation";
    wantedBy = [ "multi-user.target" ];
    after = [ "network.target" ];

    path = [ pkgs.bash pkgs.coreutils pkgs.git nodejs ];

    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
    };

    script = ''
      # Clone srchd repo if not present
      if [ ! -d "${srchdBase}/.git" ]; then
        ${pkgs.git}/bin/git clone https://github.com/dust-tt/srchd.git ${srchdBase}
      fi

      # Install dependencies if node_modules doesn't exist
      cd ${srchdBase}
      if [ ! -d "${srchdBase}/node_modules" ]; then
        ${nodejs}/bin/npm install --production=false
      fi
    '';
  };

  # Template service for per-project srchd instances
  systemd.services."srchd@" = {
    description = "srchd experiment viewer - %i";
    after = [ "network.target" "srchd-base.service" ];
    requires = [ "srchd-base.service" ];

    path = [ pkgs.bash pkgs.coreutils nodejs getPortScript ];

    serviceConfig = {
      Type = "simple";
      WorkingDirectory = "${projectsDir}/%i";
      ExecStart = "${pkgs.bash}/bin/bash -c '${nodejs}/bin/node ${srchdBase}/node_modules/.bin/tsx ${srchdBase}/src/srchd.ts serve -p $(srchd-get-port %i) ${authArgs}'";
      Restart = "always";
      RestartSec = 10;

      Environment = [
        "NODE_ENV=production"
        "HOME=${projectsDir}/%i"
      ];

      EnvironmentFile = "/etc/srchd/env";

      # Run migrations before starting (using ExecStartPre with specifier)
      ExecStartPre = "${pkgs.bash}/bin/bash -c 'cd ${projectsDir}/%i && ${nodejs}/bin/node ${srchdBase}/node_modules/.bin/drizzle-kit migrate || true'";
    };
  };

  # Discovery timer - runs periodically to find new projects
  systemd.timers.srchd-discover = {
    wantedBy = [ "timers.target" ];
    timerConfig = {
      OnBootSec = "1min";
      OnUnitActiveSec = "5min";
      Unit = "srchd-discover.service";
    };
  };

  systemd.services.srchd-discover = {
    description = "Discover and configure srchd projects";
    after = [ "srchd-base.service" "nginx.service" ];
    requires = [ "srchd-base.service" ];

    path = [ pkgs.bash pkgs.coreutils pkgs.systemd pkgs.gnugrep pkgs.gawk pkgs.certbot ];

    serviceConfig = {
      Type = "oneshot";
      ExecStart = "${discoveryScript}/bin/srchd-discover";
    };
  };

  # Main srchd.domain nginx - serves index page
  services.nginx.virtualHosts."srchd.${domain}" = {
    enableACME = true;
    forceSSL = true;

    root = srchdBase;

    locations."/" = {
      index = "index.html";
    };
  };

  # Include dynamic project configs
  services.nginx.appendHttpConfig = ''
    include /etc/nginx/srchd-projects.conf;
  '';

  # Ensure the include file exists (empty initially)
  system.activationScripts.srchd-nginx-conf = ''
    mkdir -p /etc/nginx
    touch /etc/nginx/srchd-projects.conf
  '';
}
